Seccio 01  crud :

use tienda;

// Insertar tienda con todos los datos relacionados
db.tiendas.insertOne({
  _id: "1",
  nombre: "Tienda Centro",
  direccion: "Av. Central 123",
  productos: [
    {
      _id: 1,
      categoria: "Camisetas",
      subcategoria: "Manga corta",
      marca: "Nike",
      modelo: "A123",
      descripcion: "Camiseta deportiva",
      precio: 20.99,
      tallas_disponibles: ["S", "M", "L"]
    },
    {
      _id: 2,
      categoria: "Pantalones",
      subcategoria: "Jeans",
      marca: "Levis",
      modelo: "501",
      descripcion: "Jeans clásicos",
      precio: 49.99,
      tallas_disponibles: ["M", "L", "XL"]
    },
    {
      _id: 3,
      categoria: "Zapatos",
      subcategoria: "Deportivos",
      marca: "Adidas",
      modelo: "RunX",
      descripcion: "Zapatos para correr",
      precio: 79.99,
      tallas_disponibles: ["8", "9", "10"]
    }
  ],
  usuarios: [
    {
      _id: 1,
      nombre: "Juan Pérez",
      email: "juan@example.com",
      contraseña: "123456",
      direccion_envio: "Av. Siempre Viva 123",
      telefono: "555-1234",
      carrito: {
        productos: [
          { producto_id: 1, cantidad: 2 },
          { producto_id: 2, cantidad: 1 }
        ]
      },
      pedidos: [
        {
          producto_id: 1,
          cantidad: 2,
          fecha_pedido: new Date("2024-12-02T23:39:20.817Z"),
          estado: "pendiente",
          precio_total: 40.98,
          metodo_pago: "Tarjeta de crédito"
        }
      ]
    },
    {
      _id: 2,
      nombre: "María Gómez",
      email: "maria@example.com",
      contraseña: "654321",
      direccion_envio: "Calle Falsa 456",
      telefono: "555-5678",
      carrito: {
        productos: [
          { producto_id: 3, cantidad: 1 }
        ]
      }
    }
  ],
  pedidos: [
    {
      _id: 1,
      usuario_id: 1,
      fecha_pedido: new Date("2024-12-02T17:52:39.648Z"),
      estado: "pendiente",
      productos: [
        { producto_id: 1, cantidad: 1 },
        { producto_id: 2, cantidad: 2 }
      ],
      precio_total: 120.97,
      metodo_pago: "Tarjeta de crédito"
    },
    {
      _id: 2,
      usuario_id: 2,
      fecha_pedido: new Date("2024-12-02T17:52:39.648Z"),
      estado: "enviado",
      productos: [
        { producto_id: 3, cantidad: 1 }
      ],
      precio_total: 79.99,
      metodo_pago: "PayPal"
    }
  ],
  comentarios: [
    {
      _id: 1,
      usuario_id: 1,
      producto_id: 1,
      valoracion: 4.5,
      comentario: "Excelente calidad"
    },
    {
      _id: 2,
      usuario_id: 2,
      producto_id: 2,
      valoracion: 5,
      comentario: "Muy cómodo"
    }
  ],
  productos_ordenados_por_valoracion: [
    {
      _id: 2,
      categoria: "Pantalones",
      subcategoria: "Jeans",
      marca: "Levis",
      modelo: "501",
      descripcion: "Jeans clásicos",
      precio: 49.99,
      valoracion_promedio: 5
    },
    {
      _id: 1,
      categoria: "Camisetas",
      subcategoria: "Manga corta",
      marca: "Nike",
      modelo: "A123",
      descripcion: "Camiseta deportiva",
      precio: 20.99,
      valoracion_promedio: 4.5
    }
  ]
});


Solucion playground:

Q1. Listar los productos de una categoría específica.
db.tiendas.aggregate([
    { $unwind: "$productos" },
    { $match: { "productos.categoria": "Camisetas" } }, // Cambia "Camisetas" por la categoría que desees
    { $project: { _id: 0, nombre_producto: "$productos.descripcion", precio: "$productos.precio" } }
]);


Q2. Listar los productos de una marca específica.
db.tiendas.aggregate([
    { $unwind: "$productos" },
    { $match: { "productos.marca": "Nike" } }, // Cambia "Nike" por la marca que desees
    { $project: { _id: 0, nombre_producto: "$productos.descripcion", precio: "$productos.precio" } }
]);



Q3. Listar los productos de una marca específica y los clientes que los han agregado a su carrito.

db.tiendas.aggregate([
    { $unwind: "$productos" }, // Desenrollamos los productos
    { $match: { "productos.marca": "Nike" } }, // Filtramos por la marca deseada
    { $unwind: "$usuarios" }, // Desenrollamos los usuarios
    { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos del carrito
    { 
        $match: { 
            $expr: { $eq: ["$usuarios.carrito.productos.producto_id", "$productos._id"] } // Coincidimos IDs
        }
    },
    { 
        $project: { 
            _id: 0, marca:"$productos.marca",
            producto: "$productos.descripcion", // Nombre del producto
            cliente: "$usuarios.nombre" // Nombre del cliente
        } 
    }
]);





Q4. Listar los productos que ha agregado un cliente en específico a su carrito de compras.

db.tiendas.aggregate([
    { $unwind: "$usuarios" }, // Desenrollamos los usuarios
    { $match: { "usuarios.nombre": "Juan Pérez" } }, // Filtramos por el nombre del cliente
    { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos del carrito
    { 
        $addFields: { 
            producto_detalle: {
                $arrayElemAt: [
                    {
                        $filter: {
                            input: "$productos", // Lista de productos de la tienda
                            as: "producto",
                            cond: { $eq: ["$$producto._id", "$usuarios.carrito.productos.producto_id"] } // Coincidencia por ID
                        }
                    }, 0
                ]
            }
        }
    },
    { 
        $project: { 
            _id: 0, 
            nombre_producto: "$producto_detalle.descripcion", // Descripción del producto
            cantidad: "$usuarios.carrito.productos.cantidad" // Cantidad del carrito
        }
    }
]);


Q5. Listar los productos con mejores valoraciones.

db.tiendas.aggregate([
    // Desenrollamos los productos de la tienda
    { $unwind: "$productos" },
    
    // Calculamos la valoración promedio de cada producto, filtrando los comentarios relevantes
    {
        $addFields: {
            valoracion_promedio: {
                $avg: {
                    $map: {
                        input: {
                            $filter: {
                                input: "$comentarios",
                                as: "comentario",
                                cond: { $eq: ["$$comentario.producto_id", "$productos._id"] }
                            }
                        },
                        as: "comentario",
                        in: "$$comentario.valoracion"
                    }
                }
            }
        }
    },

    // Desenrollamos los comentarios después de calcular la valoración promedio
    { $unwind: "$comentarios" },
    
    // Filtramos los comentarios con una valoración mayor que el promedio
    {
        $match: {
            $expr: { $gt: ["$comentarios.valoracion", "$valoracion_promedio"] }
        }
    },
    
    // Proyectamos los campos que queremos mostrar
    {
        $project: {
            _id: 0,
            producto_id: "$comentarios.producto_id",
            valoracion: "$comentarios.valoracion",
            comentario: "$comentarios.comentario",
            valoracion_promedio: 1  // Incluimos la valoración promedio
        }
    }
]);



Q6. Listar los productos más agregados a los carritos de compra.

db.tiendas.aggregate([
    { $unwind: "$usuarios" }, // Desenrollamos los usuarios
    { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos en el carrito
    { $group: {
        _id: "$usuarios.carrito.productos.producto_id", // Agrupamos por id de producto
        total_agregados: { $sum: "$usuarios.carrito.productos.cantidad" } // Sumamos la cantidad de cada producto
    }},
    { $lookup: {
        from: "tiendas", // Buscamos en la misma colección de tiendas
        localField: "_id", // Comparamos el _id del producto con el producto_id en los productos de la tienda
        foreignField: "productos._id", // Relacionamos con el _id del producto
        as: "producto_info" // Creamos un array con la información del producto
    }},
    { $unwind: "$producto_info" }, // Desenrollamos el array de producto_info para obtener el producto único
    { $project: {
        _id: 0,
        producto_id: "$_id", // Proyectamos el id del producto
        nombre_producto: { $arrayElemAt: ["$producto_info.productos.descripcion", 0] }, // Seleccionamos el primer elemento del array de productos
        precio_producto: { $arrayElemAt: ["$producto_info.productos.precio", 0] }, // Seleccionamos el precio del primer producto
        categoria_producto: { $arrayElemAt: ["$producto_info.productos.categoria", 0] }, // Seleccionamos la categoría del primer producto
        total_agregados: 1 // Proyectamos la cantidad total agregada
    }},
    { $sort: { total_agregados: -1 } }, // Ordenamos por cantidad total agregada
    { $limit: 10 } // Limitar a los primeros 10 productos más agregados
]);




Q7. Listar todos los pedidos (incluyendo los productos) de un cliente en específico.


 { $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $match: { "usuarios._id": 1 } }, // Filtramos por el usuario con _id: 1 (Juan Pérez)
        { $lookup: { // Hacemos un 'lookup' con la colección de pedidos
            from: "tiendas", // La misma colección
            localField: "usuarios._id", // El campo _id del usuario
            foreignField: "pedidos.usuario_id", // El campo usuario_id en los pedidos
            as: "pedidos_usuario" // Nombre del campo donde se almacenarán los pedidos encontrados
        }},
        { $unwind: "$pedidos_usuario" }, // Desenrollamos los pedidos asociados a este usuario
        { $project: { // Proyectamos los campos que necesitamos
            nombre_usuario: "$usuarios.nombre",
            pedido_id: "$pedidos_usuario._id",
            estado_pedido: "$pedidos_usuario.estado",
            productos: "$pedidos_usuario.productos"
        }}
      



Q8. Listar todos los productos que ha adquirido un cliente en específico

 { $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $match: { "usuarios._id": usuarioId } }, // Filtramos por el _id del usuario
        { $unwind: "$pedidos" }, // Desenrollamos los pedidos del usuario
        { $match: { "pedidos.usuario_id": usuarioId } }, // Filtramos por el usuario específico en los pedidos
        { $unwind: "$pedidos.productos" }, // Desenrollamos los productos dentro de cada pedido
        { $lookup: {
            from: "tiendas", // Usamos la colección correcta, que en este caso parece ser "tiendas"
            localField: "pedidos.productos.producto_id", // Usamos el producto_id del pedido
            foreignField: "productos._id", // Relacionamos con el campo _id de productos en la tienda
            as: "producto_detalles" // Los detalles del producto serán almacenados aquí
        }},
        { $unwind: { path: "$producto_detalles", preserveNullAndEmptyArrays: true } }, // Desenrollamos los detalles del producto
        // Proyección para mostrar solo los campos necesarios
        { $project: {
            nombre_cliente: "$usuarios.nombre", // Nombre del cliente
            nombre_producto: { $arrayElemAt: ["$producto_detalles.productos.descripcion", 0] }, // Nombre del producto (descripción)
            categoria_producto: { $arrayElemAt: ["$producto_detalles.productos.categoria", 0] }, // Categoría del producto
            precio_producto: { $arrayElemAt: ["$producto_detalles.productos.precio", 0] }, // Precio del producto
            cantidad: "$pedidos.productos.cantidad", // Cantidad de cada producto en el pedido
            producto_id: "$pedidos.productos.producto_id" // Incluimos el producto_id
       

Q9  Listar todos los Clientes que han comprado un producto en específico.

{ $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos del carrito
        { $match: { "usuarios.carrito.productos.producto_id": productoId } }, // Filtramos por producto_id específico
        { $project: { 
            usuario: "$usuarios.nombre", // Nombre del usuario
            producto_id: "$usuarios.carrito.productos.producto_id", // ID del producto
            cantidad: "$usuarios.carrito.productos.cantidad" // Cantidad del producto en el carrito
        }}

----------------------------------------------------------------------------------------------

Seccion 02:

Mi  index:
const app = require('./app');
const dotenv = require('dotenv');
const connectDatabase = require('./config/mongoConnection');

dotenv.config();
PORT = process.env.PORT;

connectDatabase();

app.listen(PORT, () => {
    console.log(`Servidor corriendo en el puerto ${PORT}`);
});


MI APP :
const express = require('express');
const bodyParser = require('body-parser');

const tiendaRutas = require('./routas/tiendaRutas');
const cors = require('cors');

const app = express();

app.use(cors());
app.use(bodyParser.json());
app.use('/api/tiendas', tiendaRutas);

app.get('/', (req, res) => {
    res.send('hola mundo'); 
})

app.use((req, res, next) => {
    res.status(404).json({
        code: 404,
        message: 'ruta no encontrada'
    })
})

module.exports = app;


Mi punto env:
PORT=3000
CONNECTION_STRING=mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.3.2 
DATABASE=tiendadb

Mi src:
 -- Mi cahce :
                const redis = require('redis');

// Crea el cliente Redis
const client = redis.createClient({
    socket: {
        port: 6379,
        host: 'localhost'
    }
});

// Conectar al cliente Redis al iniciar el servidor
client.connect().catch(err => {
    console.error('Error connecting to Redis:', err);
});

// Middleware que registra la solicitud y la respuesta y la almacena en Redis
const loggingAndCacheMiddleware = async (req, res, next) => {
    // Asegúrate de que `res.data` esté definido para las respuestas
    res.data = null;

    res.on('finish', async () => {
        const key = `${req.method}:${Date.now()}:${req.originalUrl}`;
        const valor = {
            clave: key,
            time: new Date(),
            req: {
                method: req.method,
                url: req.originalUrl,
                headers: req.headers,
                body: req.body
            },
            res: {
                statusCode: res.statusCode,
                statusMessage: res.statusMessage,
                // Guarda la respuesta independientemente del método
                response: res.data // Esto ahora se obtiene para ambos métodos
            }
        };
         

        // Imprimir el valor en consola
        console.log(JSON.stringify('Se guardo corretamente el cache'));


        // Guardar en Redis directamente el array de resultados
        const redisKey = `log:${valor.req.method}:${valor.time.toISOString()}`;
        
        // Serializa la respuesta para almacenarla en Redis
        const redisValue = JSON.stringify(valor.res.response);

        try {
            await client.set(redisKey, redisValue);
        } catch (error) {
            console.error('Error storing data in Redis:', error);
        }
    });

    next();
};

// Exportar el middleware
module.exports = loggingAndCacheMiddleware;

// Manejo de la desconexión de Redis cuando finaliza la aplicación
process.on('SIGINT', async () => {
    await client.quit();
    console.log('Redis client disconnected');
    process.exit(0);
});


 --Mi conneccion:
 const dotenv = require('dotenv');
const mongoose = require ('mongoose');


const connectDB = async () => {
    try {
        const db = await mongoose.connect(process.env.CONNECTION_STRING, {
            dbName: process.env.DATABASE
        });
        console.log('Conexion exitosa a la base de datos : ', db.connection.name);
    } catch (error) {
        console.log('Error en la conexion: ', error);
    }
};

module.exports = connectDB;

-- controler :
const tiendaModel = require('../modelos/tiendaModels');
const cache = require('../cache/cache');

async function getUsuarios(req, res) {
    try {
        const { tiendaId } = req.params; // El ID de la tienda se pasa como parámetro

        // Buscar la tienda por ID y obtener solo los usuarios
        const tienda = await tiendaModel.findById(tiendaId, 'usuarios');

        if (!tienda) {
            return res.status(404).json({ success: false, message: "Tienda no encontrada" });
        }

        // Extraer solo los datos que necesitamos (nombre, email, etc.) y excluir el carrito
        const usuarios = tienda.usuarios.map((usuario) => ({
            id: usuario._id,
            nombre: usuario.nombre,
            email: usuario.email,
            direccion_envio: usuario.direccion_envio,
            telefono: usuario.telefono,
        }));

        res.status(200).json({ success: true, data: usuarios });
    } catch (error) {
        if (error.name === 'CastError') {
            // Si el error es de tipo CastError, significa que el ID no es válido
            return res.status(404).json({ success: false, message: "Usuarios no encontrados" });
        }
        // Cualquier otro error se maneja normalmente
        return res.status(400).json({ success: false, message: error.message });
    }
}








// Q1. Listar los productos de una categoría específica.
const getProductosPorCategoria= async (req, res) => {
    try {
        const { categoria } = req.params; // La categoría se pasa como parámetro en la URL

        // Ejecutar la consulta de agregación
        const productos = await tiendaModel.aggregate([
            {
                $unwind: "$productos", // Descompone el arreglo de productos
            },
            {
                $match: { "productos.categoria": categoria }, // Filtra por categoría
            },
            {
                $project: {
                    _id: 0, // Excluye el campo _id
                    categoria: "$productos.categoria",
                    nombre_producto: "$productos.descripcion",
                    precio: "$productos.precio",
                },
            },
        ]);

        // Si no se encuentran productos, devolver un mensaje adecuado
        if (productos.length === 0) {
            return res.status(404).json({
                success: false,
                message: "No se encontraron productos para esta categoría.",
            });
        }
        res.data = productos;
        // Devolver los productos encontrados
        res.status(200).json({
            message: "Q1. Listar los productos de una categoría específica.",
            success: true,
            data: productos,
        });
    } catch (error) {
        // Manejo de errores
        res.status(500).json({
            success: false,
            message: "Error al obtener los productos por categoría.",
            error: error.message,
        });
    }
};
//---------------------------------------------------------------------------------






//Q2. Listar los productos de una marca spécifica.
const getProductosPorMarca = async (req, res) => {
    try {
        const { marca } = req.params; // La marca se pasa como parámetro en la URL

        // Ejecutar la consulta de agregación
        const productos = await tiendaModel.aggregate([
            {
                $unwind: "$productos", // Descompone el arreglo de productos
            },
            {
                $match: { "productos.marca": marca }, // Filtra por marca
            },
            {
                $project: {
                    _id: 0, // Excluye el campo _id
                    marca: "$productos.marca",
                    nombre_producto: "$productos.descripcion",
                    precio: "$productos.precio",
                },
            },
        ]);

        // Si no se encuentran productos, devolver un mensaje adecuado
        if (productos.length === 0) {
            return res.status(404).json({
                success: false,
                message: "No se encontraron productos para esta marca.",
            });
        }

        res.data = productos;
        // Responder con los productos encontrados
        res.status(200).json({
            success: true,
            data: productos,
        });
    } catch (error) {
        // Manejar errores
        res.status(500).json({
            success: false,
            message: "Error al obtener los productos por marca.",
            error: error.message,
        });
    }
};

//------------------------------------------------------------------------------




//Q3. Listar los productos de una marca específica y los clientes que los han agregado a su carrito.

const getProductosYClientesPorMarca = async (req, res) => {
    try {
        const { marca } = req.params; // Obtenemos la marca desde los parámetros de la solicitud

        // Usamos el pipeline de agregación
        const resultado = await tiendaModel.aggregate([
            { $unwind: "$productos" }, // Desenrollamos los productos
            { $match: { "productos.marca": marca } }, // Filtramos por la marca deseada
            { $unwind: "$usuarios" }, // Desenrollamos los usuarios
            { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos del carrito
            {
                $match: {
                    $expr: { $eq: ["$usuarios.carrito.productos.producto_id", "$productos._id"] } // Coincidimos IDs
                }
            },
            {
                $project: {
                    _id: 0,
                    marca: "$productos.marca",
                    producto: "$productos.descripcion", // Nombre del producto
                    cliente: "$usuarios.nombre" // Nombre del cliente
                }
            }
        ]);
        
        res.data = resultado;
        // Respondemos con los resultados
        res.status(200).json({
            message: "Q3. Listar los productos de una marca específica y los clientes que los han agregado a su carrito.",
            success: true,
            data: resultado,
        });
    } catch (error) {
        // Manejo de errores
        res.status(500).json({
            success: false,
            message: "Error al obtener los productos y clientes por marca.",
            error: error.message,
        });
    }
};
//--------------------------------------------------------------------------------






//Q4. Listar los productos que ha agregado un cliente en específico a su carrito de compras.

const getProductosCarritoCliente = async (req, res) => {
    try {
        const { nombreCliente } = req.params; // Recibe el nombre del cliente como parámetro

        const resultado = await tiendaModel.aggregate([
            { $unwind: "$usuarios" }, // Desenrollamos los usuarios
            { $match: { "usuarios.nombre": nombreCliente } }, // Filtramos por el nombre del cliente
            { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos del carrito
            {
                $addFields: {
                    producto_detalle: {
                        $arrayElemAt: [
                            {
                                $filter: {
                                    input: "$productos", // Lista de productos de la tienda
                                    as: "producto",
                                    cond: { $eq: ["$$producto._id", "$usuarios.carrito.productos.producto_id"] } // Coincidencia por ID
                                }
                            }, 0
                        ]
                    }
                }
            },
            {
                $project: {
                    _id: 0,
                    usuario: "$usuarios.nombre",
                    nombre_producto: "$producto_detalle.descripcion", // Descripción del producto
                    cantidad: "$usuarios.carrito.productos.cantidad" // Cantidad del carrito
                }
            }
        ]);

        if (!resultado || resultado.length === 0) {
            return res.status(404).json({
                success: false,
                message: `No se encontraron productos en el carrito para el cliente ${nombreCliente}.`
            });
        }

        res.data = resultado;
        res.status(200).json({ 
            message: "Q4. Listar los productos que ha agregado un cliente en específico a su carrito de compras.",
            success: true, 
            data: resultado });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "Error al obtener los productos en el carrito del cliente.",
            error: error.message,
        });
    }
};

//----------------------------------------------------------------------------




// Q5. Listar los productos con mejores valoraciones.
const getComentariosPorValoracion = async (req, res) => {
    try {
      const resultado = await tiendaModel.aggregate([
        // Desenrollamos los productos de la tienda
        { $unwind: "$productos" },
  
        // Calculamos la valoración promedio de cada producto, filtrando los comentarios relevantes
        {
          $addFields: {
            valoracion_promedio: {
              $avg: {
                $map: {
                  input: {
                    $filter: {
                      input: "$comentarios",
                      as: "comentario",
                      cond: { $eq: ["$$comentario.producto_id", "$productos._id"] }
                    }
                  },
                  as: "comentario",
                  in: "$$comentario.valoracion"
                }
              }
            }
          }
        },
  
        // Desenrollamos los comentarios después de calcular la valoración promedio
        { $unwind: "$comentarios" },
  
        // Filtramos los comentarios con una valoración mayor que el promedio
        {
          $match: {
            $expr: { $gt: ["$comentarios.valoracion", "$valoracion_promedio"] }
          }
        },
  
        // Proyectamos los campos que queremos mostrar
        {
          $project: {
            _id: 0,
            producto_id: "$comentarios.producto_id",
            valoracion: "$comentarios.valoracion",
            comentario: "$comentarios.comentario",
            valoracion_promedio: 1  // Incluimos la valoración promedio
          }
        }
      ]);
  
      if (!resultado || resultado.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No se encontraron comentarios con valoraciones superiores al promedio."
        });
      }
  
      res.data = resultado;
      res.status(200).json({ 
        message: "Q5. Listar los productos con mejores valoraciones.",
        success: true,
         data: resultado });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener los comentarios con valoraciones superiores al promedio.",
        error: error.message,
      });
    }
  };
  
//--------------------------------------------------------------------------------



//Q6.  Listar los productos más agregados a los carritos de compra.

const getProductosMasAgregados = async (req, res) => {
    try {
      const resultado = await tiendaModel.aggregate([
        { $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos en el carrito
        { $group: {
            _id: "$usuarios.carrito.productos.producto_id", // Agrupamos por id de producto
            total_agregados: { $sum: "$usuarios.carrito.productos.cantidad" } // Sumamos la cantidad de cada producto
        }},
        { $lookup: {
            from: "tiendas", // Buscamos en la misma colección de tiendas
            localField: "_id", // Comparamos el _id del producto con el producto_id en los productos de la tienda
            foreignField: "productos._id", // Relacionamos con el _id del producto
            as: "producto_info" // Creamos un array con la información del producto
        }},
        { $unwind: "$producto_info" }, // Desenrollamos el array de producto_info para obtener el producto único
        { $project: {
            _id: 0,
            producto_id: "$_id", // Proyectamos el id del producto
            nombre_producto: { $arrayElemAt: ["$producto_info.productos.descripcion", 0] }, // Seleccionamos el primer elemento del array de productos
            precio_producto: { $arrayElemAt: ["$producto_info.productos.precio", 0] }, // Seleccionamos el precio del primer producto
            categoria_producto: { $arrayElemAt: ["$producto_info.productos.categoria", 0] }, // Seleccionamos la categoría del primer producto
            total_agregados: 1 // Proyectamos la cantidad total agregada
        }},
        { $sort: { total_agregados: -1 } }, // Ordenamos por cantidad total agregada
        { $limit: 10 } // Limitar a los primeros 10 productos más agregados
      ]);
  
      if (!resultado || resultado.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No se encontraron productos más agregados."
        });
      }
  
      res.data = resultado;
      res.status(200).json({
         message:"Q6.  Listar los productos más agregados a los carritos de compra." ,
         success: true, 
        data: resultado });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener los productos más agregados.",
        error: error.message,
      });
    }
  };







//Q7. Listar todos los pedidos (incluyendo los productos) de un cliente en específico.
const getPedidosPorUsuario = async (req, res) => {
    try {
      const resultado = await tiendaModel.aggregate([
        { $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $match: { "usuarios._id": 1 } }, // Filtramos por el usuario con _id: 1 (Juan Pérez)
        { $lookup: { // Hacemos un 'lookup' con la colección de pedidos
            from: "tiendas", // La misma colección
            localField: "usuarios._id", // El campo _id del usuario
            foreignField: "pedidos.usuario_id", // El campo usuario_id en los pedidos
            as: "pedidos_usuario" // Nombre del campo donde se almacenarán los pedidos encontrados
        }},
        { $unwind: "$pedidos_usuario" }, // Desenrollamos los pedidos asociados a este usuario
        { $project: { // Proyectamos los campos que necesitamos
            nombre_usuario: "$usuarios.nombre",
            pedido_id: "$pedidos_usuario._id",
            estado_pedido: "$pedidos_usuario.estado",
            productos: "$pedidos_usuario.productos"
        }}
      ]);
  
      if (!resultado || resultado.length === 0) {
        return res.status(404).json({
          success: false,
          message: "No se encontraron pedidos para este usuario."
        });
      }
  
      res.data = resultado; 
      res.status(200).json({ success: true, data: resultado });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener los pedidos del usuario.",
        error: error.message,
      });
    }
  };

  //----------------------------------------------------------------------------






//Q8.Listar todos los productos que ha adquirido un cliente en específico.
  const getProductosDePedidoPorUsuario = async (req, res) => {
    try {
      const usuarioId = parseInt(req.params.id); // Obtener el ID del usuario desde la URL
  
      const resultado = await tiendaModel.aggregate([
        { $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $match: { "usuarios._id": usuarioId } }, // Filtramos por el _id del usuario
        { $unwind: "$pedidos" }, // Desenrollamos los pedidos del usuario
        { $match: { "pedidos.usuario_id": usuarioId } }, // Filtramos por el usuario específico en los pedidos
        { $unwind: "$pedidos.productos" }, // Desenrollamos los productos dentro de cada pedido
        { $lookup: {
            from: "tiendas", // Usamos la colección correcta, que en este caso parece ser "tiendas"
            localField: "pedidos.productos.producto_id", // Usamos el producto_id del pedido
            foreignField: "productos._id", // Relacionamos con el campo _id de productos en la tienda
            as: "producto_detalles" // Los detalles del producto serán almacenados aquí
        }},
        { $unwind: { path: "$producto_detalles", preserveNullAndEmptyArrays: true } }, // Desenrollamos los detalles del producto
        // Proyección para mostrar solo los campos necesarios
        { $project: {
            nombre_cliente: "$usuarios.nombre", // Nombre del cliente
            nombre_producto: { $arrayElemAt: ["$producto_detalles.productos.descripcion", 0] }, // Nombre del producto (descripción)
            categoria_producto: { $arrayElemAt: ["$producto_detalles.productos.categoria", 0] }, // Categoría del producto
            precio_producto: { $arrayElemAt: ["$producto_detalles.productos.precio", 0] }, // Precio del producto
            cantidad: "$pedidos.productos.cantidad", // Cantidad de cada producto en el pedido
            producto_id: "$pedidos.productos.producto_id" // Incluimos el producto_id
        }}
      ]);
  
      if (!resultado || resultado.length === 0) {
        return res.status(404).json({
          success: false,
          message: `No se encontraron productos para el usuario con id ${usuarioId}.`
        });
      }
  
      res.data = resultado;
      res.status(200).json({ 
        message: "Q8. Listar todos los productos que ha adquirido un cliente en específico.",
        success: true, data: resultado });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener los productos del pedido.",
        error: error.message,
      });
    }
  };
//----------------------------------------------------------------------------





//Q9  Listar todos los Clientes que han comprado un producto en específico.

const getProductosEnCarritoPorUsuario = async (req, res) => {
    try {
      const productoId = parseInt(req.params.productoId); // Obtener el ID del producto desde la URL
  
      const resultado = await tiendaModel.aggregate([
        { $unwind: "$usuarios" }, // Desenrollamos los usuarios
        { $unwind: "$usuarios.carrito.productos" }, // Desenrollamos los productos del carrito
        { $match: { "usuarios.carrito.productos.producto_id": productoId } }, // Filtramos por producto_id específico
        { $project: { 
            usuario: "$usuarios.nombre", // Nombre del usuario
            producto_id: "$usuarios.carrito.productos.producto_id", // ID del producto
            cantidad: "$usuarios.carrito.productos.cantidad" // Cantidad del producto en el carrito
        }}
      ]);
  
      if (!resultado || resultado.length === 0) {
        return res.status(404).json({
          message:'Q9  Listar todos los Clientes que han comprado un producto en específico.',
          success: false,
          message: `No se encontraron productos con el id ${productoId} en el carrito de los usuarios.`
        });
      }
  
      res.data = resultado;
      res.status(200).json({ success: true, data: resultado });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error al obtener los productos en el carrito.",
        error: error.message,
      });
    }
  };
//----------------------------------------------------------------------------  
  
  
module.exports = {
    getUsuarios,
    getProductosPorCategoria,
    getProductosPorMarca,
    getProductosYClientesPorMarca,
    getProductosCarritoCliente,
    getComentariosPorValoracion,
    getProductosMasAgregados,
    getPedidosPorUsuario,
    getProductosDePedidoPorUsuario,
    getProductosEnCarritoPorUsuario

};
 
 -- Mi model :

const mongoose = require('mongoose');  // Esta línea es esencial para poder usar mongoose


const productoSchema = mongoose.Schema({
    _id: { type: Number, required: true },
    categoria: { type: String, required: true },
    subcategoria: { type: String },
    marca: { type: String, required: true },
    modelo: { type: String },
    descripcion: { type: String, required: true },
    precio: { type: Number, required: true },
    tallas_disponibles: { type: [String], required: true }
});


const comentarioSchema = mongoose.Schema({
    _id: { type: Number, required: true },
    usuario_id: { type: Number, required: true },
    producto_id: { type: Number, required: true },
    valoracion: { type: Number, required: true },
    comentario: { type: String }
});


const pedidoSchema = mongoose.Schema({
    _id: { type: Number, required: true },
    usuario_id: { type: Number, required: true },
    fecha_pedido: { type: Date, default: Date.now },
    estado: { type: String, required: true },
    productos: [{
        producto_id: { type: Number, required: true },
        cantidad: { type: Number, required: true }
    }],
    precio_total: { type: Number, required: true },
    metodo_pago: { type: String, required: true }
});

const carritoSchema = mongoose.Schema({
    productos: [{
        producto_id: { type: Number, required: true },
        cantidad: { type: Number, required: true }
    }]
});

const usuarioSchema = mongoose.Schema({
    _id: { type: Number, required: true },
    nombre: { type: String, required: true },
    email: { type: String, required: true },
    contraseña: { type: String, required: true },
    direccion_envio: { type: String, required: true },
    telefono: { type: String, required: true },
    carrito: { type: [carritoSchema]}
});



const tiendaSchema = mongoose.Schema({
    _id: { type: Number, required: true },
    nombre: { type: String, required: true },
    direccion: { type: String, required: true },
    productos: { type: [productoSchema] },
    usuarios: { type: [usuarioSchema]},
    pedidos: { type: [pedidoSchema] },
    comentarios: { type: [comentarioSchema]}
});


const Tienda = mongoose.model('tiendas', tiendaSchema);
module.exports = Tienda

 --MI rutas:
    const express = require('express');
const router = express.Router();
const tiendaControllers = require('../controllers/tiendaControllers');
const { use } = require('../app');
const cache = require('../cache/cache');

router.get('/tiendas/:tiendaId/usuarios', tiendaControllers.getUsuarios);


//Q1. Listar los productos de una categoría específica.
router.get('/productos/categoria/:categoria', cache,tiendaControllers.getProductosPorCategoria);


//Q2. Listar los productos de una marca específica.
router.get('/productos/marca/:marca', cache,tiendaControllers.getProductosPorMarca);


//Q3. Listar los productos de una marca específica y los clientes que los han agregado a su carrito.
router.get('/productos/marca/:marca/clientes', cache,    tiendaControllers.getProductosYClientesPorMarca);

//Q4. Listar los productos que ha agregado un cliente en específico a su carrito de compras.
router.get('/productos/cliente/:nombreCliente', cache,tiendaControllers.getProductosCarritoCliente);


//Q5. Listar los comentarios de un producto con una valoración específica.
router.get('/comentarios/valoracion', cache, tiendaControllers.getComentariosPorValoracion);



//Q6.  Listar los productos más agregados a los carritos de compra.
router.get('/productos/mas-agregados', cache, tiendaControllers.getProductosMasAgregados);




//Q7.  Listar todos los pedidos (incluyendo los productos) de un cliente en específico.
router.get('/pedidos/usuario/:id', cache,tiendaControllers.getPedidosPorUsuario);


//Q8. Listar todos los productos que ha adquirido un cliente en específico.
router.get('/productos/pedido/usuario/:id', cache, tiendaControllers.getProductosDePedidoPorUsuario);


//Q9  Listar todos los Clientes que han comprado un producto en específico.
router.get('/productos-en-carrito/:productoId', cache, tiendaControllers.getProductosEnCarritoPorUsuario);

module.exports = router;



Mi docker compose :


version: '3'

services:
  mongo-primary:
    image: mongo
    command: mongod --replSet replica01
    ports:
      - "27017:27017"
    networks:
      - testing01

  mongo-secondary1:
    image: mongo
    command: mongod --replSet replica01
    ports:
      - "27018:27017"
    networks:
      - testing01
    
  mongo-secondary2:
    image: mongo
    command: mongod --replSet replica01
    ports:
      - "27019:27017"
    networks:
      - testing01

  mongo-secondary3:
    image: mongo
    command: mongod --replSet replica01
    ports:
      - "27020:27017"
    networks:
      - testing01 

  redis01:
    image: redis/redis-stack:latest
    ports:
      - "6379:6379"
      - "8001:8001"

    networks:
      - testing01
    depends_on:
      - mongo-primary
      - mongo-secondary1
      - mongo-secondary2
      - mongo-secondary3

networks:
  testing01:


 
 MI replica set:
 rs.initiate({
  _id: "replica01",
  members: [
    { _id: 0, host: "mongo-primary:27017", priority: 2 },
    { _id: 1, host: "mongo-secondary1:27017", priority: 1 },
    { _id: 2, host: "mongo-secondary2:27017", priority: 1 },
    { _id: 3, host: "mongo-secondary3:27017", priority: 1 }
  ]
})


